// function identity(arg: number): number {
//     return arg;
// }

// function identity(arg: number): number {
//     return arg;
// }

// let a: string = identity(100);
// console.log("a: ", a);


// function identity<T>(args: T): T {
//     return args;
// }

// let a = identity<number>(100);
// console.log("a: ", a);


// function identity<T, U>(args1: T, args2: U): T {
//     return args1;
// }

// let a = identity<number, string>(100, "Hundred");
// console.log("a: ", a);


// function identities<T, U>(arg1: T, arg2: U): [T, U] {
//     return [arg1, arg2];
// }

// Generic Interfaces
// This brings us on to generic interfaces; 
// let’s create a generic Identities interface to use with identities():
interface Identities<V, W> {
    id1: V,
    id2: W
}

// I have used V and W as our type variables here to demonstrate any letter
//     (or combination of valid alphanumeric names) are valid types — there is no
// significance to what you call them, other then for conventional purposes.
// We can now apply this interface as the return type of identities(), amending
// our return type to adhere to it.Let’s also console.log the arguments and their
// types for more clarification:

function identities<T, U>(arg1: T, arg2: U): Identities<T, U> {
    console.log(arg1 + ": " + typeof (arg1));
    console.log(arg2 + ": " + typeof (arg2));
    let identities: Identities<T, U> = {
        id1: arg1,
        id2: arg2
    };
    return identities;
}
// What we are doing to identities() now is passing types T and U into our
// function and Identities interface, allowing us to define the return types 
// in relation to the argument types.

// Note: If you compile your Typescript project and look for your generics, 
// you will not find any. As generics are not supported in Javascript, 
// you will not see them in the build generated by your transpiler. 
// Generics are purely a development safety net for compile time that will 
// ensure type safe abstraction of your code.




// Generic Classes

